import { supabase, PortfolioItem, isSupabaseConfigured } from '../lib/supabase';

export interface CreatePortfolioItem {
  title: string;
  category: string;
  description?: string;
  youtube_url?: string;
  cloudinary_url?: string;
  thumbnail: string;
  views?: string;
  upload_type: 'file' | 'link';
}

// Cloudinary configuration
const CLOUDINARY_CLOUD_NAME = 'dbthy4lg2';
const CLOUDINARY_UPLOAD_PRESET = 'WEBSITE';

// Helper function to extract public ID from Cloudinary URL
const extractCloudinaryPublicId = (url: string): string | null => {
  try {
    // Handle different Cloudinary URL formats
    const patterns = [
      /\/upload\/(?:v\d+\/)?([^\/\.]+)/,  // Standard upload URL
      /\/([^\/\.]+)\.[^\/]+$/,            // Simple filename
      /\/upload\/([^\/\.]+)/              // Without version
    ];
    
    for (const pattern of patterns) {
      const match = url.match(pattern);
      if (match && match[1]) {
        return match[1];
      }
    }
    return null;
  } catch (error) {
    console.error('Error extracting Cloudinary public ID:', error);
    return null;
  }
};

// Helper function to delete file from Cloudinary
const deleteFromCloudinary = async (publicId: string): Promise<boolean> => {
  try {
    console.log('üóëÔ∏è Attempting to delete from Cloudinary:', publicId);
    
    // Create signature for authenticated deletion
    const timestamp = Math.round(Date.now() / 1000);
    
    const deleteUrls = [
      `https://api.cloudinary.com/v1_1/${CLOUDINARY_CLOUD_NAME}/image/destroy`,
      `https://api.cloudinary.com/v1_1/${CLOUDINARY_CLOUD_NAME}/video/destroy`,
      `https://api.cloudinary.com/v1_1/${CLOUDINARY_CLOUD_NAME}/raw/destroy`
    ];

    for (const deleteUrl of deleteUrls) {
      try {
        const response = await fetch(deleteUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            public_id: publicId,
            timestamp: timestamp,
            upload_preset: CLOUDINARY_UPLOAD_PRESET
          }),
        });

        const result = await response.json();
        console.log(`‚òÅÔ∏è Cloudinary response (${deleteUrl}):`, result);
        
        if (result.result === 'ok' || result.result === 'not found') {
          console.log('‚úÖ Successfully deleted from Cloudinary');
          return true;
        }
      } catch (error) {
        console.log(`‚ùå Failed deletion attempt for ${deleteUrl}:`, error);
        continue;
      }
    }
    
    console.warn('‚ö†Ô∏è Could not delete from Cloudinary, but continuing...');
    return true;
  } catch (error) {
    console.error('üí• Error deleting from Cloudinary:', error);
    return true; // Don't block database deletion
  }
};

export const portfolioService = {
  // Get all portfolio items
  async getAll(): Promise<PortfolioItem[]> {
    try {
      if (!isSupabaseConfigured()) {
        console.warn('‚ö†Ô∏è Supabase not configured, returning empty array');
        return [];
      }

      console.log('üìñ Fetching all portfolio items...');
      const { data, error } = await supabase
        .from('portfolio_items')
        .select('*')
        .order('created_at', { ascending: false });

      if (error) {
        console.error('‚ùå Error fetching portfolio items:', error);
        return [];
      }

      console.log(`‚úÖ Fetched ${data?.length || 0} portfolio items`);
      return data || [];
    } catch (error) {
      console.error('üí• Error in getAll:', error);
      return [];
    }
  },

  // Add new portfolio item
  async add(item: CreatePortfolioItem): Promise<PortfolioItem | null> {
    try {
      if (!isSupabaseConfigured()) {
        throw new Error('Supabase not configured. Please set up your Supabase connection.');
      }

      console.log('‚ûï Adding new portfolio item:', item.title);
      const { data, error } = await supabase
        .from('portfolio_items')
        .insert([item])
        .select()
        .single();

      if (error) {
        console.error('‚ùå Error adding portfolio item:', error);
        throw new Error(error.message);
      }

      console.log('‚úÖ Successfully added portfolio item:', data.id);
      return data;
    } catch (error) {
      console.error('üí• Error in add:', error);
      throw error;
    }
  },

  // ENHANCED REMOVE FUNCTION WITH MULTIPLE DELETION STRATEGIES
  async remove(id: string): Promise<boolean> {
    if (!isSupabaseConfigured()) {
      console.error('‚ùå Supabase not configured');
      return false;
    }

    console.log('\nüóëÔ∏è ===== STARTING ENHANCED DELETION PROCESS =====');
    console.log('üéØ Target ID:', id);

    try {
      // STEP 1: Verify item exists and get details
      console.log('\nüìã STEP 1: Fetching item details...');
      const { data: item, error: fetchError } = await supabase
        .from('portfolio_items')
        .select('*')
        .eq('id', id)
        .maybeSingle();

      if (fetchError) {
        console.error('‚ùå Fetch error:', fetchError);
        return false;
      }

      if (!item) {
        console.log('‚ö†Ô∏è Item not found, considering deletion successful');
        return true;
      }

      console.log('‚úÖ Found item:', {
        id: item.id,
        title: item.title,
        hasCloudinaryUrl: !!item.cloudinary_url
      });

      // STEP 2: Delete from Cloudinary if needed
      if (item.cloudinary_url) {
        console.log('\n‚òÅÔ∏è STEP 2: Deleting from Cloudinary...');
        const publicId = extractCloudinaryPublicId(item.cloudinary_url);
        if (publicId) {
          await deleteFromCloudinary(publicId);
        }
      } else {
        console.log('\n‚è≠Ô∏è STEP 2: No Cloudinary URL, skipping...');
      }

      // STEP 3: Multiple deletion strategies
      console.log('\nüóÑÔ∏è STEP 3: Attempting database deletion...');
      
      // Strategy 1: Enhanced RPC function
      console.log('üîÑ Strategy 1: Enhanced RPC function...');
      try {
        const { data: rpcResult, error: rpcError } = await supabase
          .rpc('delete_portfolio_item_enhanced', { item_id: id });

        if (!rpcError && rpcResult) {
          const result = rpcResult as any;
          console.log('üìä RPC Result:', result);
          
          if (result.success) {
            console.log('‚úÖ Enhanced RPC deletion successful!');
            return true;
          } else {
            console.log('‚ùå Enhanced RPC reported failure:', result.message);
          }
        } else {
          console.log('‚ùå Enhanced RPC failed:', rpcError?.message);
        }
      } catch (rpcErr) {
        console.log('‚ùå Enhanced RPC not available:', rpcErr);
      }

      // Strategy 2: Direct DELETE with explicit transaction
      console.log('üîÑ Strategy 2: Direct DELETE with transaction...');
      try {
        const { error: deleteError, count } = await supabase
          .from('portfolio_items')
          .delete({ count: 'exact' })
          .eq('id', id);

        if (!deleteError) {
          console.log('‚úÖ Direct delete succeeded, affected rows:', count);
          
          // Verify deletion
          const { data: verifyData } = await supabase
            .from('portfolio_items')
            .select('id')
            .eq('id', id)
            .maybeSingle();

          if (!verifyData) {
            console.log('‚úÖ Deletion verified - item no longer exists');
            return true;
          } else {
            console.log('‚ùå Item still exists after deletion');
          }
        } else {
          console.error('‚ùå Direct delete failed:', deleteError);
        }
      } catch (directErr) {
        console.error('‚ùå Direct delete exception:', directErr);
      }

      // Strategy 3: Original RPC function (fallback)
      console.log('üîÑ Strategy 3: Original RPC function...');
      try {
        const { data: rpcResult, error: rpcError } = await supabase
          .rpc('delete_portfolio_item', { item_id: id });

        if (!rpcError && rpcResult) {
          console.log('‚úÖ Original RPC deletion successful!');
          return true;
        } else {
          console.log('‚ùå Original RPC failed:', rpcError?.message);
        }
      } catch (rpcErr) {
        console.log('‚ùå Original RPC not available:', rpcErr);
      }

      // Strategy 4: Force delete with admin privileges
      console.log('üîÑ Strategy 4: Force delete attempt...');
      try {
        // Try to update first to test write permissions
        const { error: updateError } = await supabase
          .from('portfolio_items')
          .update({ title: item.title + ' [DELETING]' })
          .eq('id', id);

        if (!updateError) {
          // If update works, try delete again
          const { error: forceDeleteError } = await supabase
            .from('portfolio_items')
            .delete()
            .eq('id', id);

          if (!forceDeleteError) {
            console.log('‚úÖ Force delete successful!');
            return true;
          }
        }
      } catch (forceErr) {
        console.log('‚ùå Force delete failed:', forceErr);
      }

      console.log('üí• ===== ALL DELETION STRATEGIES FAILED =====');
      return false;

    } catch (error) {
      console.error('üí• ===== DELETION PROCESS FAILED =====');
      console.error('Unexpected error:', error);
      return false;
    }
  },

  // Update portfolio item
  async update(id: string, updates: Partial<CreatePortfolioItem>): Promise<boolean> {
    try {
      if (!isSupabaseConfigured()) {
        console.warn('‚ö†Ô∏è Supabase not configured');
        return false;
      }

      console.log('üìù Updating portfolio item:', id);
      const { error } = await supabase
        .from('portfolio_items')
        .update({ ...updates, updated_at: new Date().toISOString() })
        .eq('id', id);

      if (error) {
        console.error('‚ùå Error updating portfolio item:', error);
        return false;
      }

      console.log('‚úÖ Successfully updated portfolio item');
      return true;
    } catch (error) {
      console.error('üí• Error in update:', error);
      return false;
    }
  },

  // Bulk delete with enhanced error handling
  async bulkRemove(ids: string[]): Promise<{ success: string[]; failed: string[] }> {
    const success: string[] = [];
    const failed: string[] = [];

    console.log('\nüóëÔ∏è ===== STARTING ENHANCED BULK DELETE =====');
    console.log('üìã Items to delete:', ids.length);
    console.log('üéØ IDs:', ids);

    for (let i = 0; i < ids.length; i++) {
      const id = ids[i];
      console.log(`\n--- Processing ${i + 1}/${ids.length}: ${id} ---`);
      
      try {
        const result = await this.remove(id);
        if (result) {
          success.push(id);
          console.log(`‚úÖ [${i + 1}/${ids.length}] SUCCESS: ${id}`);
        } else {
          failed.push(id);
          console.log(`‚ùå [${i + 1}/${ids.length}] FAILED: ${id}`);
        }
      } catch (error) {
        console.error(`üí• [${i + 1}/${ids.length}] EXCEPTION: ${id}`, error);
        failed.push(id);
      }

      // Small delay between deletions
      if (i < ids.length - 1) {
        await new Promise(resolve => setTimeout(resolve, 500));
      }
    }

    console.log('\nüèÅ ===== ENHANCED BULK DELETE COMPLETED =====');
    console.log('‚úÖ Successful deletions:', success.length);
    console.log('‚ùå Failed deletions:', failed.length);
    console.log('üìä Success rate:', `${Math.round((success.length / ids.length) * 100)}%`);
    
    return { success, failed };
  },

  // ENHANCED CONNECTION TEST WITH NEW RPC FUNCTIONS
  async testConnection(): Promise<{ connected: boolean; canRead: boolean; canWrite: boolean; canDelete: boolean }> {
    try {
      if (!isSupabaseConfigured()) {
        console.log('‚ùå Supabase not configured');
        return { connected: false, canRead: false, canWrite: false, canDelete: false };
      }

      console.log('\nüîç ===== TESTING CONNECTION WITH NEW FUNCTIONS =====');

      // Use the new comprehensive test function
      try {
        const { data: testResult, error: testError } = await supabase
          .rpc('test_all_permissions');

        if (!testError && testResult) {
          const result = testResult as any;
          console.log('üìä Comprehensive test results:', result);
          
          const connectionResult = {
            connected: true,
            canRead: result.can_select || false,
            canWrite: result.can_insert || false,
            canDelete: result.can_delete || false
          };

          console.log('\nüìä ===== CONNECTION TEST RESULTS =====');
          console.log('üîó Connected:', connectionResult.connected ? '‚úÖ' : '‚ùå');
          console.log('üìñ Can Read:', connectionResult.canRead ? '‚úÖ' : '‚ùå');
          console.log('‚úèÔ∏è Can Write:', connectionResult.canWrite ? '‚úÖ' : '‚ùå');
          console.log('üóëÔ∏è Can Delete:', connectionResult.canDelete ? '‚úÖ' : '‚ùå');
          
          if (result.error_messages) {
            console.log('‚ö†Ô∏è Error details:', result.error_messages);
          }
          
          console.log('=====================================\n');

          return connectionResult;
        } else {
          console.error('‚ùå Comprehensive test failed:', testError?.message);
        }
      } catch (rpcErr) {
        console.log('‚ùå New test function not available, falling back to manual tests');
      }

      // Fallback to manual testing
      console.log('üîÑ Falling back to manual permission testing...');

      // Test 1: Read
      console.log('üìñ Test 1: Read permissions...');
      const { data: readData, error: readError } = await supabase
        .from('portfolio_items')
        .select('id, title')
        .limit(1);

      const canRead = !readError;
      console.log('üìñ Read result:', canRead ? '‚úÖ SUCCESS' : '‚ùå FAILED', readError?.message);

      // Test 2: Write
      console.log('‚úèÔ∏è Test 2: Write permissions...');
      const testItem = {
        title: `üß™ Test Item ${Date.now()}`,
        category: 'test',
        thumbnail: 'https://via.placeholder.com/300x200/FF6B6B/FFFFFF?text=TEST',
        upload_type: 'link' as const,
        description: 'This is a test item for permission testing'
      };

      const { data: writeData, error: writeError } = await supabase
        .from('portfolio_items')
        .insert([testItem])
        .select()
        .single();

      const canWrite = !writeError && writeData;
      console.log('‚úèÔ∏è Write result:', canWrite ? '‚úÖ SUCCESS' : '‚ùå FAILED', writeError?.message);

      // Test 3: Delete
      console.log('üóëÔ∏è Test 3: Delete permissions...');
      let canDelete = false;
      if (canWrite && writeData) {
        console.log('üéØ Attempting to delete test item:', writeData.id);
        
        const deleteResult = await this.remove(writeData.id);
        canDelete = deleteResult;
        console.log('üóëÔ∏è Delete result:', canDelete ? '‚úÖ SUCCESS' : '‚ùå FAILED');
      } else {
        console.log('‚è≠Ô∏è Skipping delete test - write failed');
      }

      const result = {
        connected: true,
        canRead,
        canWrite,
        canDelete
      };

      console.log('\nüìä ===== MANUAL CONNECTION TEST RESULTS =====');
      console.log('üîó Connected:', result.connected ? '‚úÖ' : '‚ùå');
      console.log('üìñ Can Read:', result.canRead ? '‚úÖ' : '‚ùå');
      console.log('‚úèÔ∏è Can Write:', result.canWrite ? '‚úÖ' : '‚ùå');
      console.log('üóëÔ∏è Can Delete:', result.canDelete ? '‚úÖ' : '‚ùå');
      console.log('=====================================\n');

      return result;
    } catch (error) {
      console.error('üí• Connection test failed:', error);
      return { connected: false, canRead: false, canWrite: false, canDelete: false };
    }
  },

  // Force refresh with cache clearing
  async forceRefresh(): Promise<PortfolioItem[]> {
    try {
      console.log('üîÑ Force refreshing portfolio data...');
      
      // Clear any caches
      if (typeof window !== 'undefined') {
        Object.keys(localStorage).forEach(key => {
          if (key.includes('portfolio') || key.includes('supabase')) {
            localStorage.removeItem(key);
          }
        });
      }

      // Get fresh data
      const items = await this.getAll();
      console.log('‚úÖ Force refresh completed, items:', items.length);
      return items;
    } catch (error) {
      console.error('üí• Error in forceRefresh:', error);
      return [];
    }
  }
};